; ModuleID = 'phpdbg_help-strip-renamed.bc'
source_filename = "/home/travis/build/orestisfl/compilation-database/build/php-src/sapi/phpdbg/phpdbg_help.c"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%0 = type { i8*, i64, i8*, i64, i8, i32 (%1*)*, %0*, i8*, %0*, i8 }
%1 = type { i32, i64, i64, %2, %3, i8*, i64, %1*, %1* }
%2 = type { i8*, i64 }
%3 = type { i8*, i8* }
%4 = type { [11 x %57], %57, %57, %5*, %14*, %30, i32, i8*, %36, %1*, %37, %40, %40, %57, %57, %57, %57, %57*, %57*, i8, void (i8*)*, %42*, i8*, i64, %9*, %49, i32, i32, i8, i8, %9* (%53*, i32)*, %9* (%53*, i32)*, %9* (%49*, i8*)*, %57, %81*, %60*, %61*, %62*, [3 x %63], i32, i64 (%64*, i8*, i64)*, i32, %79, i64, [2 x i8*], [3 x %80*], i8*, i8, %81*, %64* (%74*, i8*, i8*, i32, %29**, %76*)*, [500 x i8], i32, %83, [1 x %85]*, i64, i8*, i8*, i32, i32, i64 }
%5 = type { %6*, %5*, %49*, %8*, %49, %5*, %57*, i8**, %49* }
%6 = type { i8*, %7, %7, %7, i32, i32, i8, i8, i8, i8 }
%7 = type { i32 }
%8 = type { %9 }
%9 = type { i8, [3 x i8], i32, %29*, %10*, %8*, i32, i32, %26*, i32*, i32, %6*, i32, i32, %29**, i32, i32, %27*, %28*, %57*, %29*, i32, i32, %29*, i32, i32, %49*, i32, i8**, [6 x i8*] }
%10 = type { i8, %29*, %10*, i32, i32, i32, i32, %49*, %49*, %49*, %57, %57, %57, %8*, %8*, %8*, %8*, %8*, %8*, %8*, %8*, %8*, %8*, %8*, %8*, %8*, %11, %14* (%10*)*, %13* (%10*, %49*, i32)*, i32 (%10*, %10*)*, %8* (%10*, %29*)*, i32 (%49*, i8**, i64*, %18*)*, i32 (%49*, %10*, i8*, i64, %19*)*, i32, i32, %10**, %10**, %20**, %22**, %24 }
%11 = type { %12*, %8*, %8*, %8*, %8*, %8*, %8* }
%12 = type { void (%13*)*, i32 (%13*)*, %49* (%13*)*, void (%13*, %49*)*, void (%13*)*, void (%13*)*, void (%13*)* }
%13 = type { %14, %49, %12*, i64 }
%14 = type { %15, i32, %10*, %17*, %57*, [1 x %49] }
%15 = type { i32, %16 }
%16 = type { i32 }
%17 = type { i32, void (%14*)*, void (%14*)*, %14* (%49*)*, %49* (%49*, %49*, i32, i8**, %49*)*, void (%49*, %49*, %49*, i8**)*, %49* (%49*, %49*, i32, %49*)*, void (%49*, %49*, %49*)*, %49* (%49*, %49*, i32, i8**)*, %49* (%49*, %49*)*, void (%49*, %49*)*, i32 (%49*, %49*, i32, i8**)*, void (%49*, %49*, i8**)*, i32 (%49*, %49*, i32)*, void (%49*, %49*)*, %57* (%49*)*, %8* (%14**, %29*, %49*)*, i32 (%29*, %14*, %5*, %49*)*, %8* (%14*)*, %29* (%14*)*, i32 (%49*, %49*)*, i32 (%49*, %49*, i32)*, i32 (%49*, i64*)*, %57* (%49*, i32*)*, i32 (%49*, %10**, %8**, %14**)*, %57* (%49*, %49**, i32*)*, i32 (i8, %49*, %49*, %49*)*, i32 (%49*, %49*, %49*)* }
%18 = type opaque
%19 = type opaque
%20 = type { %21*, %29*, i32 }
%21 = type { %29*, %10*, %29* }
%22 = type { %21*, %23* }
%23 = type { %10* }
%24 = type { %25 }
%25 = type { %29*, i32, i32, %29* }
%26 = type { %29*, i64, i8, i8 }
%27 = type { i32, i32, i32 }
%28 = type { i32, i32, i32, i32 }
%29 = type { %15, i64, i64, [1 x i8] }
%30 = type { i32, %31*, %5* }
%31 = type { %14, %13*, %5*, %5*, %49, %49, %49, %49*, i64, %49, %32, %5, i8, %49*, i32 }
%32 = type { %31*, i32, %33, %35 }
%33 = type { [4 x %34] }
%34 = type { %31*, %31* }
%35 = type { %31* }
%36 = type { i32, i8*, i8*, i8*, i8*, i32 }
%37 = type { %38, %39, i32, void ()* }
%38 = type { void (i32)* }
%39 = type { [16 x i64] }
%40 = type { i64, i64, i8, %41* }
%41 = type { [2 x %41*] }
%42 = type { i32, %43*, i8, %42*, %42*, %57, %57*, %29*, %29*, %48 }
%43 = type { %44, i64, i32, %45*, %57, %46*, %47 }
%44 = type { %49* }
%45 = type { %15 }
%46 = type { %43, %43, %57 }
%47 = type { %57 }
%48 = type { %57 }
%49 = type { %50, %51, %52 }
%50 = type { i64 }
%51 = type { i32 }
%52 = type { i32 }
%53 = type { %54, i8*, %29*, i32, i8 }
%54 = type { %55 }
%55 = type { i8*, i32, %56, i64 (i8*, i8*, i64)*, i64 (i8*)*, void (i8*)* }
%56 = type { i64, i64, i8*, i8*, i8*, void (i8*)* }
%57 = type { %15, %58, i32, %59*, i32, i32, i32, i32, i64, void (%49*)* }
%58 = type { i32 }
%59 = type { %49, i64, %29* }
%60 = type { i8*, i8*, %60* }
%61 = type { %61*, %62* }
%62 = type { %62*, %29*, %10*, %29*, %6*, %6* }
%63 = type { %81*, i32 }
%64 = type { %65*, i8*, %69, %69, %74*, i8*, %49, i8, i8, [16 x i8], i32, %78*, %81*, i8*, %78*, i64, i8*, i64, i64, i64, i64, %64* }
%65 = type { {}*, i64 (%64*, i8*, i64)*, i32 (%64*, i32)*, i32 (%64*)*, i8*, i32 (%64*, i64, i32, i64*)*, i32 (%64*, i32, i8**)*, i32 (%64*, %66*)*, i32 (%64*, i32, i32, i8*)* }
%66 = type { %67 }
%67 = type { i64, i64, i64, i32, i32, i32, i32, i64, i64, i64, i64, %68, %68, %68, [3 x i64] }
%68 = type { i64, i64 }
%69 = type { %70*, %70*, %64* }
%70 = type { %71*, %49, %70*, %70*, i32, %69*, %72, %78* }
%71 = type { i32 (%64*, %70*, %72*, %72*, i64*, i32)*, void (%70*)*, i8* }
%72 = type { %73*, %73* }
%73 = type { %73*, %73*, %72*, i8*, i64, i8, i8, i32 }
%74 = type { %75*, i8*, i32 }
%75 = type { %64* (%74*, i8*, i8*, i32, %29**, %76*)*, i32 (%74*, %64*)*, i32 (%74*, %64*, %66*)*, i32 (%74*, i8*, i32, %66*, %76*)*, %64* (%74*, i8*, i8*, i32, %29**, %76*)*, i8*, i32 (%74*, i8*, i32, %76*)*, i32 (%74*, i8*, i8*, i32, %76*)*, i32 (%74*, i8*, i32, i32, %76*)*, i32 (%74*, i8*, i32, %76*)*, i32 (%74*, i8*, i32, i8*, %76*)* }
%76 = type { %77*, %49, %78* }
%77 = type { void (%76*, i32, i32, i8*, i32, i64, i64, i8*)*, void (%77*)*, %49, i32, i64, i64 }
%78 = type { %15, i32, i32, i8* }
%79 = type { i8, i32, i32, i8*, i8*, i32, i8*, i32 }
%80 = type { i8*, i64, [12 x i8] }
%81 = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %82*, %81*, i32, i32, i64, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i64, i32, [20 x i8] }
%82 = type { %82*, %81*, i32 }
%83 = type { i8*, i8, %84*, %84* }
%84 = type opaque
%85 = type { [8 x i64], i32, %39 }
%86 = type { i8*, i8* }

@0 = private unnamed_addr constant [8 x i8] c"aliases\00", align 1
@1 = private unnamed_addr constant [16 x i8] c"show alias list\00", align 1
@phpdbg_prompt_commands = external dso_local constant [0 x %0], align 8
@2 = private unnamed_addr constant [8 x i8] c"options\00", align 1
@3 = private unnamed_addr constant [21 x i8] c"command line options\00", align 1
@4 = private unnamed_addr constant [9 x i8] c"overview\00", align 1
@5 = private unnamed_addr constant [14 x i8] c"help overview\00", align 1
@6 = private unnamed_addr constant [11 x i8] c"phpdbginit\00", align 1
@7 = private unnamed_addr constant [23 x i8] c"phpdbginit file format\00", align 1
@8 = private unnamed_addr constant [7 x i8] c"syntax\00", align 1
@9 = private unnamed_addr constant [16 x i8] c"syntax overview\00", align 1
@phpdbg_help_commands = hidden constant [6 x %0] [%0 { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @0, i32 0, i32 0), i64 7, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @1, i32 0, i32 0), i64 15, i8 97, i32 (%1*)* @phpdbg_do_help_aliases, %0* bitcast (i8* getelementptr (i8, i8* bitcast ([0 x %0]* @phpdbg_prompt_commands to i8*), i64 1280) to %0*), i8* null, %0* null, i8 0 }, %0 { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @2, i32 0, i32 0), i64 7, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @3, i32 0, i32 0), i64 20, i8 0, i32 (%1*)* null, %0* bitcast (i8* getelementptr (i8, i8* bitcast ([0 x %0]* @phpdbg_prompt_commands to i8*), i64 1280) to %0*), i8* null, %0* null, i8 0 }, %0 { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @4, i32 0, i32 0), i64 8, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @5, i32 0, i32 0), i64 13, i8 0, i32 (%1*)* null, %0* bitcast (i8* getelementptr (i8, i8* bitcast ([0 x %0]* @phpdbg_prompt_commands to i8*), i64 1280) to %0*), i8* null, %0* null, i8 0 }, %0 { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @6, i32 0, i32 0), i64 10, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @7, i32 0, i32 0), i64 22, i8 0, i32 (%1*)* null, %0* bitcast (i8* getelementptr (i8, i8* bitcast ([0 x %0]* @phpdbg_prompt_commands to i8*), i64 1280) to %0*), i8* null, %0* null, i8 0 }, %0 { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @8, i32 0, i32 0), i64 6, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @9, i32 0, i32 0), i64 15, i8 0, i32 (%1*)* null, %0* bitcast (i8* getelementptr (i8, i8* bitcast ([0 x %0]* @phpdbg_prompt_commands to i8*), i64 1280) to %0*), i8* null, %0* null, i8 0 }, %0 zeroinitializer], align 16
@phpdbg_globals = external dso_local global %4, align 8
@10 = private unnamed_addr constant [5 x i8] c"\1B[1m\00", align 1
@11 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@12 = private unnamed_addr constant [5 x i8] c"\1B[0m\00", align 1
@13 = private unnamed_addr constant [21 x i8] c"<help %r msg=\22%s\22 />\00", align 1
@14 = private unnamed_addr constant [5 x i8] c"help\00", align 1
@15 = private unnamed_addr constant [14 x i8] c"overrun=\22%lu\22\00", align 1
@16 = private unnamed_addr constant [28 x i8] c"Output overrun of %lu bytes\00", align 1
@17 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@18 = private unnamed_addr constant [40 x i8] c"Command: **%s**  Alias: **%c**  **%s**\0A\00", align 1
@19 = private unnamed_addr constant [10 x i8] c"overview!\00", align 1
@20 = private unnamed_addr constant [40 x i8] c"\0Arequested help page could not be found\00", align 1
@21 = private unnamed_addr constant [11 x i8] c"duplicate!\00", align 1
@22 = private unnamed_addr constant [33 x i8] c"type=\22ambiguousalias\22 alias=\22%s\22\00", align 1
@23 = private unnamed_addr constant [43 x i8] c"Internal help error, non-unique alias \22%c\22\00", align 1
@24 = private unnamed_addr constant [64 x i8] c"Below are the aliased, short versions of all supported commands\00", align 1
@25 = private unnamed_addr constant [18 x i8] c"<helpcommands %r>\00", align 1
@26 = private unnamed_addr constant [8 x i8] c"command\00", align 1
@27 = private unnamed_addr constant [30 x i8] c"alias=\22%c\22 name=\22%s\22 tip=\22%s\22\00", align 1
@28 = private unnamed_addr constant [18 x i8] c" %c     %-20s  %s\00", align 1
@29 = private unnamed_addr constant [11 x i8] c"subcommand\00", align 1
@30 = private unnamed_addr constant [62 x i8] c"parent_alias=\22%c\22 alias=\22%c\22 parent=\22%s\22 name=\22%-*s\22 tip=\22%s\22\00", align 1
@31 = private unnamed_addr constant [21 x i8] c" %c %c   %s %-*s  %s\00", align 1
@32 = private unnamed_addr constant [16 x i8] c"</helpcommands>\00", align 1
@33 = private unnamed_addr constant [2 x i8] c"h\00", align 1
@34 = private unnamed_addr constant [10 x i8] c"aliasinfo\00", align 1
@35 = private unnamed_addr constant [19 x i8] c" %c     %-20s  %s\0A\00", align 1
@36 = private unnamed_addr constant [14 x i8] c"<helpaliases>\00", align 1
@37 = private unnamed_addr constant [6 x i8] c"alias\00", align 1
@38 = private unnamed_addr constant [15 x i8] c"</helpaliases>\00", align 1
@39 = private unnamed_addr constant [9 x i8] c"aliases!\00", align 1
@40 = private unnamed_addr constant [2188 x i8] c"\0A**phpdbg** is a lightweight, powerful and easy to use debugging platform for PHP5.4+\0AIt supports the following commands:\0A\0A**Information**\0A  **list**      list PHP source\0A  **info**      displays information on the debug session\0A  **print**     show opcodes\0A  **frame**     select a stack frame and print a stack frame summary\0A  **generator** show active generators or select a generator frame\0A  **back**      shows the current backtrace\0A  **help**      provide help on a topic\0A\0A**Starting and Stopping Execution**\0A  **exec**      set execution context\0A  **stdin**     set executing script from stdin\0A  **run**       attempt execution\0A  **step**      continue execution until other line is reached\0A  **continue**  continue execution\0A  **until**     continue execution up to the given location\0A  **next**      continue execution up to the given location and halt on the first line after it\0A  **finish**    continue up to end of the current execution frame\0A  **leave**     continue up to end of the current execution frame and halt after the calling instruction\0A  **break**     set a breakpoint at the specified target\0A  **watch**     set a watchpoint on $variable\0A  **clear**     clear one or all breakpoints\0A  **clean**     clean the execution environment\0A\0A**Miscellaneous**\0A  **set**       set the phpdbg configuration\0A  **source**    execute a phpdbginit script\0A  **register**  register a phpdbginit function as a command alias\0A  **sh**        shell a command\0A  **ev**        evaluate some code\0A  **quit**      exit phpdbg\0A\0AType **help <command>** or (**help alias**) to get detailed help on any of the above commands, for example **help list** or **h l**.  Note that help will also match partial commands if unique (and list out options if not unique), so **help exp** will give help on the **export** command, but **help ex** will list the summary for **exec** and **export**.\0A\0AType **help aliases** to show a full alias list, including any registered phpdginit functions\0AType **help syntax** for a general introduction to the command syntax.\0AType **help options** for a list of phpdbg command line options.\0AType **help phpdbginit** to show how to customise the debugger environment.\00", align 1
@41 = private unnamed_addr constant [3019 x i8] c"\0ABelow are the command line options supported by phpdbg\0A\0A**Command Line Options and Flags**\0A  **Option**  **Example Argument**    **Description**\0A  **-c**      **-c**/my/php.ini       Set php.ini file to load\0A  **-d**      **-d**memory_limit=4G   Set a php.ini directive\0A  **-n**                          Disable default php.ini\0A  **-q**                          Suppress welcome banner\0A  **-v**                          Enable oplog output\0A  **-b**                          Disable colour\0A  **-i**      **-i**my.init           Set .phpdbginit file\0A  **-I**                          Ignore default .phpdbginit\0A  **-O**      **-O**my.oplog          Sets oplog output file\0A  **-r**                          Run execution context\0A  **-rr**                         Run execution context and quit after execution (not respecting breakpoints)\0A  **-e**                          Generate extended information for debugger/profiler\0A  **-E**                          Enable step through eval, careful!\0A  **-s**      **-s=**, **-s**=foo         Read code to execute from stdin with an optional delimiter\0A  **-S**      **-S**cli               Override SAPI name, careful!\0A  **-l**      **-l**4000              Setup remote console ports\0A  **-a**      **-a**192.168.0.3       Setup remote console bind address\0A  **-x**                          Enable xml output (instead of normal text output)\0A  **-p**      **-p**, **-p=func**, **-p* **   Output opcodes and quit\0A  **-h**                          Print the help overview\0A  **-V**                          Print version number\0A  **--**      **--** arg1 arg2        Use to delimit phpdbg arguments and php $argv; append any $argv argument after it\0A\0A**Reading from stdin**\0A\0AThe **-s** option allows inputting a script to execute directly from stdin. The given delimiter (\22foo\22 in the example) needs to be specified at the end of the input on its own line, followed by a line break. If **-rr** has been specified, it is allowed to omit the delimiter (**-s=**) and it will read until EOF. See also the help entry for the **stdin** command.\0A\0A**Remote Console Mode**\0A\0AThis mode is enabled by specifying the **-a** option. Phpdbg will bind only to the loopback interface by default, and this can only be overridden by explicitly setting the remote console bind address using the **-a** option. If **-a** is specied without an argument, then phpdbg will bind to all available interfaces.  You should be aware of the security implications of doing this, so measures should be taken to secure this service if bound to a publicly accessible interface/port.\0A\0A**Opcode output**\0A\0AOutputting opcodes requires that a file path is passed as last argument. Modes of execution:\0A**-p** Outputs the main execution context\0A**-p* **Outputs all opcodes in the whole file (including classes and functions)\0A**-p=function_name** Outputs opcodes of a given function in the file\0A**-p=class_name::** Outputs opcodes of all the methods of a given class\0A**-p=class_name::method** Outputs opcodes of a given method\00", align 1
@42 = private unnamed_addr constant [947 x i8] c"\0APhpdgb uses an debugger script file to initialize the debugger context.  By default, phpdbg looks for the file named **.phpdbginit** in the current working directory.  This location can be overridden on the command line using the **-i** switch (see **help options** for a more details).\0A\0ADebugger scripts can also be executed using the **source** command.\0A\0AA script file can contain a sequence of valid debugger commands, comments and embedded PHP code. \0A\0AComment lines are prefixed by the **#** character.  Note that comments are only allowed in script files and not in interactive sessions.\0A\0APHP code is delimited by the start and end escape tags **<:** and **:>**. PHP code can be used to define application context for a debugging session and also to extend the debugger by defining and **register** PHP functions as new commands.\0A\0AAlso note that executing a **clear** command will cause the current **phpdbginit** to be reparsed / reloaded.\00", align 1
@43 = private unnamed_addr constant [1776 x i8] c"\0ACommands start with a keyword, and some (**break**, **info**, **set**, **print** and **list**) may include a subcommand keyword.  All keywords are lower case but also have a single letter alias that may be used as an alternative to typing in thekeyword in full.  Note some aliases are uppercase, and that keywords cannot be abbreviated other than by substitution by the alias.\0A\0ASome commands take an argument.  Arguments are typed according to their format:\0A     *  **omitted**\0A     *  **address**      **0x** followed by a hex string\0A     *  **number**       an optionally signed number\0A     *  **method**       a valid **Class::methodName** expression\0A     *  **func#op**      a valid **Function name** follow by # and an integer\0A     *  **method#op**    a valid **Class::methodName** follow by # and an integer\0A     *  **string**       a general string\0A     *  **function**     a valid **Function name**\0A     *  **file:line**    a valid **filename** follow by : and an integer\0A\0AIn some cases the type of the argument enables the second keyword to be omitted.\0A\0AType **help** for an overview of all commands and type **help <command>** to get detailed help on any specific command.\0A\0A**Valid Examples**\0A\0A     $P quit\0A     $P q\0A     Quit the debugger\0A\0A     $P ev $total[2]\0A     Evaluate and print the variable $total[2] in the current stack frame\0A    \0A     $P break 200\0A     $P b my_source.php:200\0A     Break at line 200 in the current source and in file **my_source.php**. \0A\0A     $P b @ ClassX::get_args if $arg[0] == \22fred\22\0A     $P b ~ 3\0A     Break at ClassX::get_args() if $arg[0] == \22fred\22 and delete breakpoint 3\0A\0A**Examples of invalid commands**\0A     $P #This is a comment\0A     Comments introduced by the **#** character are only allowed in **phpdbginit** script files.\00", align 1
@44 = private unnamed_addr constant [320 x i8] c"\0ANote that aliases can be used for either command or sub-command keywords or both, so **info b** is a synomyn for **info break** and **l func** for **list func**, etc.\0A\0ANote that help will also accept any alias as a parameter and provide help on that command, for example **h p** will provide help on the print command.\00", align 1
@45 = private unnamed_addr constant [86 x i8] c"\0AParameter is not unique. For detailed help select help on one of the above commands.\00", align 1
@46 = private unnamed_addr constant [5 x i8] c"back\00", align 1
@47 = private unnamed_addr constant [321 x i8] c"Provide a formatted backtrace using the standard debug_backtrace() functionality.  An optional unsigned integer argument specifying the maximum number of frames to be traced; if omitted then a complete backtrace is given.\0A\0A**Examples**\0A\0A    $P back 5\0A    $P t \0A \0AA backtrace can be executed at any time during execution.\00", align 1
@48 = private unnamed_addr constant [6 x i8] c"break\00", align 1
@49 = private unnamed_addr constant [2305 x i8] c"Breakpoints can be set at a range of targets within the execution environment.  Execution will be paused if the program flow hits a breakpoint.  The break target can be one of the following types:\0A\0A  **Target**   **Alias** **Purpose**\0A  **at**       **@**     specify breakpoint by location and condition\0A  **del**      **~**     delete breakpoint by breakpoint identifier number\0A\0A**Break at** takes two arguments. The first is any valid target. The second is a valid PHP expression which will trigger the break in execution, if evaluated as true in a boolean context at the specified target.\0A\0ANote that breakpoints can also be disabled and re-enabled by the **set break** command.\0A\0A**Examples**\0A\0A    $P break test.php:100\0A    $P b test.php:100\0A    Break execution at line 100 of test.php\0A\0A    $P break 200\0A    $P b 200\0A    Break execution at line 200 of the currently PHP script file\0A\0A    $P break \\\\mynamespace\\\\my_function\0A    $P b \\\\mynamespace\\\\my_function\0A    Break execution on entry to \\\\mynamespace\\\\my_function\0A\0A    $P break classX::method\0A    $P b classX::method\0A    Break execution on entry to classX::method\0A\0A    $P break 0x7ff68f570e08\0A    $P b 0x7ff68f570e08\0A    Break at the opline at the address 0x7ff68f570e08\0A\0A    $P break my_function#14\0A    $P b my_function#14\0A    Break at the opline #14 of the function my_function\0A\0A    $P break \\\\my\\\\class::method#2\0A    $P b \\\\my\\\\class::method#2\0A    Break at the opline #2 of the method \\\\my\\\\class::method\0A\0A    $P break test.php:#3\0A    $P b test.php:#3\0A    Break at opline #3 in test.php\0A\0A    $P break if $cnt > 10\0A    $P b if $cnt > 10\0A    Break when the condition ($cnt > 10) evaluates to true\0A\0A    $P break at phpdbg::isGreat if $opt == 'S'\0A    $P break @ phpdbg::isGreat if $opt == 'S'\0A    Break at any opcode in phpdbg::isGreat when the condition ($opt == 'S') is true\0A\0A    $P break at test.php:20 if !isset($x)\0A    Break at every opcode on line 20 of test.php when the condition evaluates to true\0A\0A    $P break ZEND_ADD\0A    $P b ZEND_ADD\0A    Break on any occurrence of the opcode ZEND_ADD\0A\0A    $P break del 2\0A    $P b ~ 2\0A    Remove breakpoint 2\0A\0ANote: Conditional breaks are costly in terms of runtime overhead. Use them only when required as they significantly slow execution.\0A\0ANote: An address is only valid for the current compilation.\00", align 1
@50 = private unnamed_addr constant [6 x i8] c"clean\00", align 1
@51 = private unnamed_addr constant [481 x i8] c"Classes, constants or functions can only be declared once in PHP.  You may experience errors during a debug session if you attempt to recompile a PHP source.  The clean command clears the Zend runtime tables which holds the sets of compiled classes, constants and functions, releasing any associated storage back into the storage pool.  This enables recompilation to take place.\0A\0ANote that you cannot selectively trim any of these resource pools. You can only do a complete clean.\00", align 1
@52 = private unnamed_addr constant [6 x i8] c"clear\00", align 1
@53 = private unnamed_addr constant [228 x i8] c"Clearing breakpoints means you can once again run code without interruption.\0A\0ANote: use break delete N to clear a specific breakpoint.\0A\0ANote: if all breakpoints are cleared, then the PHP script will run until normal completion.\00", align 1
@54 = private unnamed_addr constant [3 x i8] c"ev\00", align 1
@55 = private unnamed_addr constant [769 x i8] c"The **ev** command takes a string expression which it evaluates and then displays. It evaluates in the context of the lowest (that is the executing) frame, unless this has first been explicitly changed by issuing a **frame** command. \0A\0A**Examples**\0A\0A    $P ev $variable\0A    Will print_r($variable) on the console, if it is defined\0A\0A    $P ev $variable = \22Hello phpdbg :)\22\0A    Will set $variable in the current scope\0A\0ANote that **ev** allows any valid PHP expression including assignments, function calls and other write statements.  This enables you to change the environment during execution, so care is needed here.  You can even call PHP functions which have breakpoints defined. \0A\0ANote: **ev** will always show the result, so do not prefix the code with **return**\00", align 1
@56 = private unnamed_addr constant [5 x i8] c"exec\00", align 1
@57 = private unnamed_addr constant [429 x i8] c"The **exec** command sets the execution context, that is the script to be executed.  The execution context must be defined either by executing the **exec** command or by using the **-e** command line option.\0A\0ANote that the **exec** command also can be used to replace a previously defined execution context.\0A\0A**Examples**\0A\0A    $P exec /tmp/script.php\0A    $P e /tmp/script.php\0A    Set the execution context to **/tmp/script.php**\00", align 1
@58 = private unnamed_addr constant [6 x i8] c"stdin\00", align 1
@59 = private unnamed_addr constant [489 x i8] c"The **stdin** command takes a string serving as delimiter. It will then read all the input from stdin until encountering the given delimiter on a standalone line. It can also be passed at startup using the **-s=** command line option (the delimiter then is optional if **-rr** is also passed - in that case it will just read until EOF).\0AThis input will be then compiled as PHP code and set as execution context.\0A\0A**Example**\0A\0A    $P stdin foo\0A    <?php\0A    echo \22Hello, world!\\n\22;\0A    foo\00", align 1
@60 = private unnamed_addr constant [7 x i8] c"finish\00", align 1
@61 = private unnamed_addr constant [470 x i8] c"The **finish** command causes control to be passed back to the vm, continuing execution.  Any breakpoints that are encountered within the current stack frame will be skipped.  Execution will then continue until the next breakpoint after leaving the stack frame or until completion of the script\0A\0ANote when **step**ping is enabled, any opcode steps within the current stack frame are also skipped. \0A\0ANote **finish** will trigger a \22not executing\22 error if not executing.\00", align 1
@62 = private unnamed_addr constant [6 x i8] c"frame\00", align 1
@63 = private unnamed_addr constant [558 x i8] c"The **frame** takes an optional integer argument. If omitted, then the current frame is displayed. If specified, then the current scope is set to the corresponding frame listed in a **back** trace. This can be used to allowing access to the variables in a higher stack frame than that currently being executed.\0A\0A**Examples**\0A\0A    $P frame 2\0A    $P ev $count\0A    Go to frame 2 and print out variable **$count** in that frame\0A\0ANote that this frame scope is discarded when execution continues, with the execution frame then reset to the lowest executing frame.\00", align 1
@64 = private unnamed_addr constant [10 x i8] c"generator\00", align 1
@65 = private unnamed_addr constant [729 x i8] c"The **generator** command takes an optional integer argument. If omitted, then a list of the currently active generators is displayed. If specified then the current scope is set to the frame of the generator with the corresponding object handle. This can be used to inspect any generators not in the current **back** trace.\0A\0A**Examples**\0A\0A    $P generator\0A    List of generators, with the #id being the object handle, e.g.:\0A    #3: my_generator(argument=\22value\22) at test.php:5\0A    $P g 3\0A    $P ev $i\0A    Go to frame of generator with object handle 3 and print out variable **$i** in that frame\0A\0ANote that this frame scope is discarded when execution continues, with the execution frame then reset to the lowest executing frame.\00", align 1
@66 = private unnamed_addr constant [5 x i8] c"info\00", align 1
@67 = private unnamed_addr constant [764 x i8] c"**info** commands provide quick access to various types of information about the PHP environment\0ABy default general information about environment and PHP build is shown.\0ASpecific info commands are show below:\0A\0A  **Target**   **Alias**  **Purpose**\0A  **break**      **b**      show current breakpoints\0A  **files**      **F**      show included files\0A  **classes**    **c**      show loaded classes\0A  **funcs**      **f**      show loaded functions\0A  **error**      **e**      show last error\0A  **constants**  **d**      show user-defined constants\0A  **vars**       **v**      show active variables\0A  **globals**    **g**      show superglobal variables\0A  **literal**    **l**      show active literal constants\0A  **memory**     **m**      show memory manager stats\00", align 1
@68 = private unnamed_addr constant [6 x i8] c"leave\00", align 1
@69 = private unnamed_addr constant [643 x i8] c"The **leave** command causes control to be passed back to the vm, continuing execution.  Any breakpoints that are encountered within the current stack frame will be skipped.  In effect a temporary breakpoint is associated with any return opcode, so that a break in execution occurs before leaving the current stack frame. This allows inspection / modification of any frame variables including the return value before it is returned\0A\0A**Examples**\0A\0A    $P leave\0A    $P L\0A\0ANote when **step**ping is enabled, any opcode steps within the current stack frame are also skipped. \0A\0ANote **leave** will trigger a \22not executing\22 error if not executing.\00", align 1
@70 = private unnamed_addr constant [5 x i8] c"list\00", align 1
@71 = private unnamed_addr constant [1379 x i8] c"The list command displays source code for the given argument.  The target type is specficied by a second subcommand keyword:\0A\0A  **Type**     **Alias**  **Purpose**\0A  **lines**    **l**      List N lines from the current execution point\0A  **func**     **f**      List the complete source for a specified function\0A  **method**   **m**      List the complete source for a specified class::method\0A  **class**    **c**      List the complete source for a specified class\0A\0ANote that the context of **lines**, **func** and **method** can be determined by parsing the argument, so these subcommands are optional.  However, you must specify the **class** keyword to list off a class.\0A\0A**Examples**\0A\0A    $P list 2\0A    $P l l 2\0A    List the next 2 lines from the current file\0A\0A    $P list my_function\0A    $P l f my_function\0A    List the source of the function **my_function**\0A\0A    $P list func .mine\0A    $P l f .mine\0A    List the source of the method **mine** from the active class in scope\0A\0A    $P list m my::method\0A    $P l my::method\0A    List the source of **my::method**\0A\0A    $P list c myClass\0A    $P l c myClass\0A    List the source of **myClass**\0A\0ANote that functions and classes can only be listed if the corresponding classes and functions table in the Zend executor has a corresponding entry.  You can use the compile command to populate these tables for a given execution context.\00", align 1
@72 = private unnamed_addr constant [9 x i8] c"continue\00", align 1
@73 = private unnamed_addr constant [230 x i8] c"Continue with execution after hitting a break or watchpoint\0A\0A**Examples**\0A\0A    $P continue\0A    $P c\0A    Continue executing until the next break or watchpoint\0A\0ANote **continue** will trigger a \22not running\22 error if not executing.\00", align 1
@74 = private unnamed_addr constant [6 x i8] c"print\00", align 1
@75 = private unnamed_addr constant [1539 x i8] c"By default, print will show the opcodes of the current execution context.\0AOther printing commands give access to instruction information.\0ASpecific printers loaded are show below:\0A\0A  **Type**    **Alias**  **Purpose**\0A  **exec**    **e**      print out the instructions in the execution context\0A  **opline**  **o**      print out the instruction in the current opline\0A  **class**   **c**      print out the instructions in the specified class\0A  **method**  **m**      print out the instructions in the specified method\0A  **func**    **f**      print out the instructions in the specified function\0A  **stack**   **s**      print out the instructions in the current stack\0A\0AIn case passed argument does not match a specific printing command, it will treat it as function or method name and print its opcodes\0A\0A**Examples**\0A\0A    $P print class \\\\my\\\\class\0A    $P p c \\\\my\\\\class\0A    Print the instructions for the methods in \\\\my\\\\class\0A\0A    $P print method \\\\my\\\\class::method\0A    $P p m \\\\my\\\\class::method\0A    Print the instructions for \\\\my\\\\class::method\0A\0A    $P print func .getSomething\0A    $P p f .getSomething\0A    Print the instructions for ::getSomething in the active scope\0A\0A    $P print func my_function\0A    $P p f my_function\0A    Print the instructions for the global function my_function\0A\0A    $P print opline\0A    $P p o\0A    Print the instruction for the current opline\0A\0A    $P print exec\0A    $P p e\0A    Print the instructions for the execution context\0A\0A    $P print stack\0A    $P p s\0A    Print the instructions for the current stack\00", align 1
@76 = private unnamed_addr constant [9 x i8] c"register\00", align 1
@77 = private unnamed_addr constant [258 x i8] c"Register any global function for use as a command in phpdbg console\0A\0A**Examples**\0A\0A    $P register scandir\0A    $P R scandir\0A    Will register the scandir function for use in phpdbg\0A\0ANote: arguments passed as strings, return (if present) print_r'd on console\00", align 1
@78 = private unnamed_addr constant [4 x i8] c"run\00", align 1
@79 = private unnamed_addr constant [541 x i8] c"Enter the vm, starting execution. Execution will then continue until the next breakpoint or completion of the script. Add parameters you want to use as $argv. Add a trailing **< filename** for reading STDIN from a file.\0A\0A**Examples**\0A\0A    $P run\0A    $P r\0A    Will cause execution of the context, if it is set\0A\0A    $P r test < foo.txt\0A    Will execute with $argv[1] == \22test\22 and read from the foo.txt file for STDIN\0A\0ANote that the execution context must be set. If not previously compiled, then the script will be compiled before execution.\00", align 1
@80 = private unnamed_addr constant [4 x i8] c"set\00", align 1
@81 = private unnamed_addr constant [1277 x i8] c"The **set** command is used to configure how phpdbg looks and behaves.  Specific set commands are as follows:\0A\0A   **Type**    **Alias**    **Purpose**\0A   **prompt**     **p**     set the prompt\0A   **color**      **c**     set color  <element> <color>\0A   **colors**     **C**     set colors [<on|off>]\0A   **oplog**      **O**     set oplog [output]\0A   **break**      **b**     set break **id** <on|off>\0A   **breaks**     **B**     set breaks [<on|off>]\0A   **quiet**      **q**     set quiet [<on|off>]\0A   **stepping**   **s**     set stepping [<opcode|line>]\0A   **refcount**   **r**     set refcount [<on|off>] \0A\0AValid colors are **none**, **white**, **red**, **green**, **yellow**, **blue**, **purple**, **cyan** and **black**.  All colours except **none** can be followed by an optional **-bold** or **-underline** qualifier.\0A\0AColor elements can be one of **prompt**, **notice**, or **error**.\0A\0A**Examples**\0A\0A     $P S C on\0A     Set colors on\0A\0A     $P set p >\0A     $P set color prompt white-bold\0A     Set the prompt to a bold >\0A\0A     $P S c error red-bold\0A     Use red bold for errors\0A\0A     $P S refcount on\0A     Enable refcount display when hitting watchpoints\0A\0A     $P S b 4 off\0A     Temporarily disable breakpoint 4.  This can be subsequently reenabled by a **S b 4 on**.\0A\00", align 1
@82 = private unnamed_addr constant [3 x i8] c"sh\00", align 1
@83 = private unnamed_addr constant [192 x i8] c"Direct access to shell commands saves having to switch windows/consoles\0A\0A**Examples**\0A\0A    $P sh ls /usr/src/php-src\0A    Will execute ls /usr/src/php-src, displaying the output in the console\00", align 1
@84 = private unnamed_addr constant [7 x i8] c"source\00", align 1
@85 = private unnamed_addr constant [192 x i8] c"Sourcing a **phpdbginit** script during your debugging session might save some time.\0A\0A**Examples**\0A\0A    $P source /my/init\0A    $P < /my/init\0A    Will execute the phpdbginit file at /my/init\0A\0A\00", align 1
@86 = private unnamed_addr constant [7 x i8] c"export\00", align 1
@87 = private unnamed_addr constant [197 x i8] c"Exporting breakpoints allows you to share, and or save your current debugging session\0A\0A**Examples**\0A\0A    $P export /my/exports\0A    $P > /my/exports\0A    Will export all breakpoints to /my/exports\0A\0A\00", align 1
@88 = private unnamed_addr constant [5 x i8] c"step\00", align 1
@89 = private unnamed_addr constant [121 x i8] c"Execute opcodes until next line\0A\0A**Examples**\0A\0A    $P s\0A    Will continue and break again in the next encountered line\0A\0A\00", align 1
@90 = private unnamed_addr constant [5 x i8] c"next\00", align 1
@91 = private unnamed_addr constant [486 x i8] c"The **next** command causes control to be passed back to the vm, continuing execution. Any breakpoints that are encountered before the next source line will be skipped. Execution willbe stopped when that line is left.\0A\0ANote when **step**ping is enabled, any opcode steps within the current line are also skipped. \0A\0ANote that if the next line is **not** executed then **all** subsequent breakpoints will be skipped. \0A\0ANote **next** will trigger a \22not executing\22 error if not executing.\00", align 1
@92 = private unnamed_addr constant [6 x i8] c"until\00", align 1
@93 = private unnamed_addr constant [522 x i8] c"The **until** command causes control to be passed back to the vm, continuing execution. Any breakpoints that are encountered before the next source line will be skipped. Execution will then continue until the next breakpoint or completion of the script\0A\0ANote when **step**ping is enabled, any opcode steps within the current line are also skipped. \0A\0ANote that if the next line is **not** executed then **all** subsequent breakpoints will be skipped. \0A\0ANote **until** will trigger a \22not executing\22 error if not executing.\00", align 1
@94 = private unnamed_addr constant [6 x i8] c"watch\00", align 1
@95 = private unnamed_addr constant [1541 x i8] c"Sets watchpoints on variables as long as they are defined\0APassing no parameter to **watch**, lists all actually active watchpoints\0A\0A**Format for $variable**\0A\0A   **$var**      Variable $var\0A   **$var[]**    All array elements of $var\0A   **$var->**    All properties of $var\0A   **$var->a**   Property $var->a\0A   **$var[b]**   Array element with key b in array $var\0A\0ASubcommands of **watch**:\0A\0A   **Type**     **Alias**      **Purpose**\0A   **array**       **a**       Sets watchpoint on array/object to observe if an entry is added or removed\0A   **recursive**   **r**       Watches variable recursively and automatically adds watchpoints if some entry is added to an array/object\0A   **delete**      **d**       Removes watchpoint\0A\0ANote when **recursive** watchpoints are removed, watchpoints on all the children are removed too\0A\0A**Examples**\0A\0A     $P watch\0A     List currently active watchpoints\0A\0A     $P watch $array\0A     $P w $array\0A     Set watchpoint on $array\0A\0A     $P watch recursive $obj->\0A     $P w r $obj->\0A     Set recursive watchpoint on $obj->\0A\0A     $P watch delete $obj->a\0A     $P w d $obj->a\0A     Remove watchpoint $obj->a\0A\0ATechnical note: If using this feature with a debugger, you will get many segmentation faults, each time when a memory page containing a watched address is hit.\0A                You then you can continue, phpdbg will remove the write protection, so that the program can continue.\0A                If phpdbg could not handle that segfault, the same segfault is triggered again and this time phpdbg will abort.\00", align 1
@phpdbg_help_text = hidden global [32 x %86] [%86 { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @19, i32 0, i32 0), i8* getelementptr inbounds ([2188 x i8], [2188 x i8]* @40, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([8 x i8], [8 x i8]* @2, i32 0, i32 0), i8* getelementptr inbounds ([3019 x i8], [3019 x i8]* @41, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @6, i32 0, i32 0), i8* getelementptr inbounds ([947 x i8], [947 x i8]* @42, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @8, i32 0, i32 0), i8* getelementptr inbounds ([1776 x i8], [1776 x i8]* @43, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @39, i32 0, i32 0), i8* getelementptr inbounds ([320 x i8], [320 x i8]* @44, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([11 x i8], [11 x i8]* @21, i32 0, i32 0), i8* getelementptr inbounds ([86 x i8], [86 x i8]* @45, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @46, i32 0, i32 0), i8* getelementptr inbounds ([321 x i8], [321 x i8]* @47, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @48, i32 0, i32 0), i8* getelementptr inbounds ([2305 x i8], [2305 x i8]* @49, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @50, i32 0, i32 0), i8* getelementptr inbounds ([481 x i8], [481 x i8]* @51, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @52, i32 0, i32 0), i8* getelementptr inbounds ([228 x i8], [228 x i8]* @53, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @54, i32 0, i32 0), i8* getelementptr inbounds ([769 x i8], [769 x i8]* @55, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @56, i32 0, i32 0), i8* getelementptr inbounds ([429 x i8], [429 x i8]* @57, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @58, i32 0, i32 0), i8* getelementptr inbounds ([489 x i8], [489 x i8]* @59, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @60, i32 0, i32 0), i8* getelementptr inbounds ([470 x i8], [470 x i8]* @61, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @62, i32 0, i32 0), i8* getelementptr inbounds ([558 x i8], [558 x i8]* @63, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([10 x i8], [10 x i8]* @64, i32 0, i32 0), i8* getelementptr inbounds ([729 x i8], [729 x i8]* @65, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @66, i32 0, i32 0), i8* getelementptr inbounds ([764 x i8], [764 x i8]* @67, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @68, i32 0, i32 0), i8* getelementptr inbounds ([643 x i8], [643 x i8]* @69, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @70, i32 0, i32 0), i8* getelementptr inbounds ([1379 x i8], [1379 x i8]* @71, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @72, i32 0, i32 0), i8* getelementptr inbounds ([230 x i8], [230 x i8]* @73, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @74, i32 0, i32 0), i8* getelementptr inbounds ([1539 x i8], [1539 x i8]* @75, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([9 x i8], [9 x i8]* @76, i32 0, i32 0), i8* getelementptr inbounds ([258 x i8], [258 x i8]* @77, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @78, i32 0, i32 0), i8* getelementptr inbounds ([541 x i8], [541 x i8]* @79, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([4 x i8], [4 x i8]* @80, i32 0, i32 0), i8* getelementptr inbounds ([1277 x i8], [1277 x i8]* @81, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([3 x i8], [3 x i8]* @82, i32 0, i32 0), i8* getelementptr inbounds ([192 x i8], [192 x i8]* @83, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @84, i32 0, i32 0), i8* getelementptr inbounds ([192 x i8], [192 x i8]* @85, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([7 x i8], [7 x i8]* @86, i32 0, i32 0), i8* getelementptr inbounds ([197 x i8], [197 x i8]* @87, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @88, i32 0, i32 0), i8* getelementptr inbounds ([121 x i8], [121 x i8]* @89, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([5 x i8], [5 x i8]* @90, i32 0, i32 0), i8* getelementptr inbounds ([486 x i8], [486 x i8]* @91, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @92, i32 0, i32 0), i8* getelementptr inbounds ([522 x i8], [522 x i8]* @93, i32 0, i32 0) }, %86 { i8* getelementptr inbounds ([6 x i8], [6 x i8]* @94, i32 0, i32 0), i8* getelementptr inbounds ([1541 x i8], [1541 x i8]* @95, i32 0, i32 0) }, %86 zeroinitializer], align 16

; Function Attrs: nounwind uwtable
define hidden i32 @phpdbg_do_help_aliases(%1* %0) #0 {
  %2 = alloca %1*, align 8
  %3 = alloca %0*, align 8
  %4 = alloca %0*, align 8
  %5 = alloca i32, align 4
  store %1* %0, %1** %2, align 8
  %6 = bitcast %0** %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #6
  %7 = bitcast %0** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #6
  %8 = bitcast i32* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %8) #6
  %9 = load i32, i32* getelementptr inbounds (%4, %4* @phpdbg_globals, i32 0, i32 38, i64 1, i32 1), align 8
  %10 = call i32 (i32, i32, i8*, i8*, i8*, ...) @phpdbg_print(i32 3, i32 %9, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @14, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @11, i32 0, i32 0), i8* getelementptr inbounds ([64 x i8], [64 x i8]* @24, i32 0, i32 0))
  %11 = load i32, i32* getelementptr inbounds (%4, %4* @phpdbg_globals, i32 0, i32 38, i64 1, i32 1), align 8
  %12 = call i32 (i32, i8*, ...) @phpdbg_xml_internal(i32 %11, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @25, i32 0, i32 0))
  store %0* getelementptr inbounds ([0 x %0], [0 x %0]* @phpdbg_prompt_commands, i32 0, i32 0), %0** %3, align 8
  br label %13

13:                                               ; preds = %94, %1
  %14 = load %0*, %0** %3, align 8
  %15 = getelementptr inbounds %0, %0* %14, i32 0, i32 0
  %16 = load i8*, i8** %15, align 8
  %17 = icmp ne i8* %16, null
  br i1 %17, label %18, label %97

18:                                               ; preds = %13
  %19 = load %0*, %0** %3, align 8
  %20 = getelementptr inbounds %0, %0* %19, i32 0, i32 4
  %21 = load i8, i8* %20, align 8
  %22 = sext i8 %21 to i32
  %23 = icmp ne i32 %22, 0
  br i1 %23, label %24, label %93

24:                                               ; preds = %18
  %25 = load %0*, %0** %3, align 8
  %26 = getelementptr inbounds %0, %0* %25, i32 0, i32 4
  %27 = load i8, i8* %26, align 8
  %28 = sext i8 %27 to i32
  %29 = icmp ne i32 %28, 104
  br i1 %29, label %30, label %93

30:                                               ; preds = %24
  %31 = load i32, i32* getelementptr inbounds (%4, %4* @phpdbg_globals, i32 0, i32 38, i64 1, i32 1), align 8
  %32 = load %0*, %0** %3, align 8
  %33 = getelementptr inbounds %0, %0* %32, i32 0, i32 4
  %34 = load i8, i8* %33, align 8
  %35 = sext i8 %34 to i32
  %36 = load %0*, %0** %3, align 8
  %37 = getelementptr inbounds %0, %0* %36, i32 0, i32 0
  %38 = load i8*, i8** %37, align 8
  %39 = load %0*, %0** %3, align 8
  %40 = getelementptr inbounds %0, %0* %39, i32 0, i32 2
  %41 = load i8*, i8** %40, align 8
  %42 = call i32 (i32, i32, i8*, i8*, i8*, ...) @phpdbg_print(i32 3, i32 %31, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @26, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @27, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @28, i32 0, i32 0), i32 %35, i8* %38, i8* %41)
  %43 = load %0*, %0** %3, align 8
  %44 = getelementptr inbounds %0, %0* %43, i32 0, i32 6
  %45 = load %0*, %0** %44, align 8
  %46 = icmp ne %0* %45, null
  br i1 %46, label %47, label %92

47:                                               ; preds = %30
  %48 = load %0*, %0** %3, align 8
  %49 = getelementptr inbounds %0, %0* %48, i32 0, i32 1
  %50 = load i64, i64* %49, align 8
  %51 = sub i64 19, %50
  %52 = trunc i64 %51 to i32
  store i32 %52, i32* %5, align 4
  %53 = load %0*, %0** %3, align 8
  %54 = getelementptr inbounds %0, %0* %53, i32 0, i32 6
  %55 = load %0*, %0** %54, align 8
  store %0* %55, %0** %4, align 8
  br label %56

56:                                               ; preds = %88, %47
  %57 = load %0*, %0** %4, align 8
  %58 = getelementptr inbounds %0, %0* %57, i32 0, i32 4
  %59 = load i8, i8* %58, align 8
  %60 = icmp ne i8 %59, 0
  br i1 %60, label %61, label %91

61:                                               ; preds = %56
  %62 = load %0*, %0** %4, align 8
  %63 = getelementptr inbounds %0, %0* %62, i32 0, i32 4
  %64 = load i8, i8* %63, align 8
  %65 = icmp ne i8 %64, 0
  br i1 %65, label %66, label %87

66:                                               ; preds = %61
  %67 = load i32, i32* getelementptr inbounds (%4, %4* @phpdbg_globals, i32 0, i32 38, i64 1, i32 1), align 8
  %68 = load %0*, %0** %3, align 8
  %69 = getelementptr inbounds %0, %0* %68, i32 0, i32 4
  %70 = load i8, i8* %69, align 8
  %71 = sext i8 %70 to i32
  %72 = load %0*, %0** %4, align 8
  %73 = getelementptr inbounds %0, %0* %72, i32 0, i32 4
  %74 = load i8, i8* %73, align 8
  %75 = sext i8 %74 to i32
  %76 = load %0*, %0** %3, align 8
  %77 = getelementptr inbounds %0, %0* %76, i32 0, i32 0
  %78 = load i8*, i8** %77, align 8
  %79 = load i32, i32* %5, align 4
  %80 = load %0*, %0** %4, align 8
  %81 = getelementptr inbounds %0, %0* %80, i32 0, i32 0
  %82 = load i8*, i8** %81, align 8
  %83 = load %0*, %0** %4, align 8
  %84 = getelementptr inbounds %0, %0* %83, i32 0, i32 2
  %85 = load i8*, i8** %84, align 8
  %86 = call i32 (i32, i32, i8*, i8*, i8*, ...) @phpdbg_print(i32 3, i32 %67, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @29, i32 0, i32 0), i8* getelementptr inbounds ([62 x i8], [62 x i8]* @30, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @31, i32 0, i32 0), i32 %71, i32 %75, i8* %78, i32 %79, i8* %82, i8* %85)
  br label %87

87:                                               ; preds = %66, %61
  br label %88

88:                                               ; preds = %87
  %89 = load %0*, %0** %4, align 8
  %90 = getelementptr inbounds %0, %0* %89, i32 1
  store %0* %90, %0** %4, align 8
  br label %56

91:                                               ; preds = %56
  br label %92

92:                                               ; preds = %91, %30
  br label %93

93:                                               ; preds = %92, %24, %18
  br label %94

94:                                               ; preds = %93
  %95 = load %0*, %0** %3, align 8
  %96 = getelementptr inbounds %0, %0* %95, i32 1
  store %0* %96, %0** %3, align 8
  br label %13

97:                                               ; preds = %13
  %98 = load i32, i32* getelementptr inbounds (%4, %4* @phpdbg_globals, i32 0, i32 38, i64 1, i32 1), align 8
  %99 = call i32 (i32, i8*, ...) @phpdbg_xml_internal(i32 %98, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @32, i32 0, i32 0))
  %100 = call i32 @97(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @33, i32 0, i32 0), i64 1, %0** %3, %0* getelementptr inbounds ([0 x %0], [0 x %0]* @phpdbg_prompt_commands, i32 0, i32 0))
  %101 = load i32, i32* getelementptr inbounds (%4, %4* @phpdbg_globals, i32 0, i32 38, i64 1, i32 1), align 8
  %102 = load %0*, %0** %3, align 8
  %103 = getelementptr inbounds %0, %0* %102, i32 0, i32 4
  %104 = load i8, i8* %103, align 8
  %105 = sext i8 %104 to i32
  %106 = load %0*, %0** %3, align 8
  %107 = getelementptr inbounds %0, %0* %106, i32 0, i32 0
  %108 = load i8*, i8** %107, align 8
  %109 = load %0*, %0** %3, align 8
  %110 = getelementptr inbounds %0, %0* %109, i32 0, i32 2
  %111 = load i8*, i8** %110, align 8
  %112 = call i32 (i32, i32, i8*, i8*, i8*, ...) @phpdbg_print(i32 3, i32 %101, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @34, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @27, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @35, i32 0, i32 0), i32 %105, i8* %108, i8* %111)
  %113 = load i32, i32* getelementptr inbounds (%4, %4* @phpdbg_globals, i32 0, i32 38, i64 1, i32 1), align 8
  %114 = call i32 (i32, i8*, ...) @phpdbg_xml_internal(i32 %113, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @36, i32 0, i32 0))
  %115 = load %0*, %0** %3, align 8
  %116 = getelementptr inbounds %0, %0* %115, i32 0, i32 1
  %117 = load i64, i64* %116, align 8
  %118 = sub i64 19, %117
  %119 = trunc i64 %118 to i32
  store i32 %119, i32* %5, align 4
  %120 = load %0*, %0** %3, align 8
  %121 = getelementptr inbounds %0, %0* %120, i32 0, i32 6
  %122 = load %0*, %0** %121, align 8
  store %0* %122, %0** %4, align 8
  br label %123

123:                                              ; preds = %155, %97
  %124 = load %0*, %0** %4, align 8
  %125 = getelementptr inbounds %0, %0* %124, i32 0, i32 4
  %126 = load i8, i8* %125, align 8
  %127 = icmp ne i8 %126, 0
  br i1 %127, label %128, label %158

128:                                              ; preds = %123
  %129 = load %0*, %0** %4, align 8
  %130 = getelementptr inbounds %0, %0* %129, i32 0, i32 4
  %131 = load i8, i8* %130, align 8
  %132 = icmp ne i8 %131, 0
  br i1 %132, label %133, label %154

133:                                              ; preds = %128
  %134 = load i32, i32* getelementptr inbounds (%4, %4* @phpdbg_globals, i32 0, i32 38, i64 1, i32 1), align 8
  %135 = load %0*, %0** %3, align 8
  %136 = getelementptr inbounds %0, %0* %135, i32 0, i32 4
  %137 = load i8, i8* %136, align 8
  %138 = sext i8 %137 to i32
  %139 = load %0*, %0** %4, align 8
  %140 = getelementptr inbounds %0, %0* %139, i32 0, i32 4
  %141 = load i8, i8* %140, align 8
  %142 = sext i8 %141 to i32
  %143 = load %0*, %0** %3, align 8
  %144 = getelementptr inbounds %0, %0* %143, i32 0, i32 0
  %145 = load i8*, i8** %144, align 8
  %146 = load i32, i32* %5, align 4
  %147 = load %0*, %0** %4, align 8
  %148 = getelementptr inbounds %0, %0* %147, i32 0, i32 0
  %149 = load i8*, i8** %148, align 8
  %150 = load %0*, %0** %4, align 8
  %151 = getelementptr inbounds %0, %0* %150, i32 0, i32 2
  %152 = load i8*, i8** %151, align 8
  %153 = call i32 (i32, i32, i8*, i8*, i8*, ...) @phpdbg_print(i32 3, i32 %134, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @37, i32 0, i32 0), i8* getelementptr inbounds ([62 x i8], [62 x i8]* @30, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @31, i32 0, i32 0), i32 %138, i32 %142, i8* %145, i32 %146, i8* %149, i8* %152)
  br label %154

154:                                              ; preds = %133, %128
  br label %155

155:                                              ; preds = %154
  %156 = load %0*, %0** %4, align 8
  %157 = getelementptr inbounds %0, %0* %156, i32 1
  store %0* %157, %0** %4, align 8
  br label %123

158:                                              ; preds = %123
  %159 = load i32, i32* getelementptr inbounds (%4, %4* @phpdbg_globals, i32 0, i32 38, i64 1, i32 1), align 8
  %160 = call i32 (i32, i8*, ...) @phpdbg_xml_internal(i32 %159, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @38, i32 0, i32 0))
  %161 = call i8* @96(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @39, i32 0, i32 0))
  call void @pretty_print(i8* %161)
  %162 = bitcast i32* %5 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %162) #6
  %163 = bitcast %0** %4 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %163) #6
  %164 = bitcast %0** %3 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %164) #6
  ret i32 0
}

; Function Attrs: nounwind uwtable
define hidden void @pretty_print(i8* %0) #0 {
  %2 = alloca i8*, align 8
  %3 = alloca i8*, align 8
  %4 = alloca i8*, align 8
  %5 = alloca i8*, align 8
  %6 = alloca i8*, align 8
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i8*, align 8
  %10 = alloca i8*, align 8
  %11 = alloca i32, align 4
  %12 = alloca i32, align 4
  %13 = alloca i32, align 4
  %14 = alloca i32, align 4
  %15 = alloca i8*, align 8
  %16 = alloca i32, align 4
  %17 = alloca i32, align 4
  %18 = alloca i32, align 4
  store i8* %0, i8** %2, align 8
  %19 = bitcast i8** %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %19) #6
  %20 = bitcast i8** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %20) #6
  %21 = bitcast i8** %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %21) #6
  %22 = bitcast i8** %6 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %22) #6
  %23 = call i8* @phpdbg_get_prompt()
  store i8* %23, i8** %6, align 8
  %24 = bitcast i32* %7 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %24) #6
  %25 = load i8*, i8** %6, align 8
  %26 = call i64 @strlen(i8* %25) #7
  %27 = trunc i64 %26 to i32
  store i32 %27, i32* %7, align 4
  %28 = bitcast i32* %8 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %28) #6
  %29 = load i8*, i8** getelementptr inbounds (%4, %4* @phpdbg_globals, i32 0, i32 44, i64 0), align 8
  %30 = call i64 @strlen(i8* %29) #7
  %31 = trunc i64 %30 to i32
  store i32 %31, i32* %8, align 4
  %32 = bitcast i8** %9 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %32) #6
  %33 = load i64, i64* getelementptr inbounds (%4, %4* @phpdbg_globals, i32 0, i32 54), align 8
  %34 = and i64 %33, 131072
  %35 = icmp ne i64 %34, 0
  %36 = zext i1 %35 to i64
  %37 = select i1 %35, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @10, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @11, i32 0, i32 0)
  store i8* %37, i8** %9, align 8
  %38 = bitcast i8** %10 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %38) #6
  %39 = load i64, i64* getelementptr inbounds (%4, %4* @phpdbg_globals, i32 0, i32 54), align 8
  %40 = and i64 %39, 131072
  %41 = icmp ne i64 %40, 0
  %42 = zext i1 %41 to i64
  %43 = select i1 %41, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @12, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @11, i32 0, i32 0)
  store i8* %43, i8** %10, align 8
  %44 = bitcast i32* %11 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %44) #6
  %45 = load i8*, i8** %9, align 8
  %46 = call i64 @strlen(i8* %45) #7
  %47 = trunc i64 %46 to i32
  store i32 %47, i32* %11, align 4
  %48 = bitcast i32* %12 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %48) #6
  %49 = call i32 @phpdbg_get_terminal_width()
  store i32 %49, i32* %12, align 4
  %50 = bitcast i32* %13 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %50) #6
  store i32 0, i32* %13, align 4
  %51 = bitcast i32* %14 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %51) #6
  store i32 0, i32* %14, align 4
  %52 = bitcast i8** %15 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %52) #6
  store i8* null, i8** %15, align 8
  %53 = bitcast i32* %16 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %53) #6
  store i32 0, i32* %16, align 4
  %54 = bitcast i32* %17 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %54) #6
  store i32 0, i32* %17, align 4
  %55 = load i64, i64* getelementptr inbounds (%4, %4* @phpdbg_globals, i32 0, i32 54), align 8
  %56 = and i64 %55, 4294967296
  %57 = icmp ne i64 %56, 0
  br i1 %57, label %58, label %62

58:                                               ; preds = %1
  %59 = load i32, i32* getelementptr inbounds (%4, %4* @phpdbg_globals, i32 0, i32 38, i64 1, i32 1), align 8
  %60 = load i8*, i8** %2, align 8
  %61 = call i32 (i32, i8*, ...) @phpdbg_xml_internal(i32 %59, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @13, i32 0, i32 0), i8* %60)
  store i32 1, i32* %18, align 4
  br label %349

62:                                               ; preds = %1
  %63 = load i8*, i8** %2, align 8
  store i8* %63, i8** %4, align 8
  br label %64

64:                                               ; preds = %136, %62
  %65 = load i8*, i8** %4, align 8
  %66 = load i8, i8* %65, align 1
  %67 = icmp ne i8 %66, 0
  br i1 %67, label %68, label %139

68:                                               ; preds = %64
  %69 = load i8*, i8** %4, align 8
  %70 = getelementptr inbounds i8, i8* %69, i64 0
  %71 = load i8, i8* %70, align 1
  %72 = sext i8 %71 to i32
  %73 = icmp eq i32 %72, 42
  %74 = xor i1 %73, true
  %75 = xor i1 %74, true
  %76 = zext i1 %75 to i32
  %77 = sext i32 %76 to i64
  %78 = call i64 @llvm.expect.i64(i64 %77, i64 0)
  %79 = icmp ne i64 %78, 0
  br i1 %79, label %80, label %93

80:                                               ; preds = %68
  %81 = load i8*, i8** %4, align 8
  %82 = getelementptr inbounds i8, i8* %81, i64 1
  %83 = load i8, i8* %82, align 1
  %84 = sext i8 %83 to i32
  %85 = icmp eq i32 %84, 42
  br i1 %85, label %86, label %93

86:                                               ; preds = %80
  %87 = load i32, i32* %11, align 4
  %88 = sub i32 %87, 2
  %89 = load i32, i32* %13, align 4
  %90 = add i32 %89, %88
  store i32 %90, i32* %13, align 4
  %91 = load i8*, i8** %4, align 8
  %92 = getelementptr inbounds i8, i8* %91, i32 1
  store i8* %92, i8** %4, align 8
  br label %135

93:                                               ; preds = %80, %68
  %94 = load i8*, i8** %4, align 8
  %95 = getelementptr inbounds i8, i8* %94, i64 0
  %96 = load i8, i8* %95, align 1
  %97 = sext i8 %96 to i32
  %98 = icmp eq i32 %97, 36
  %99 = xor i1 %98, true
  %100 = xor i1 %99, true
  %101 = zext i1 %100 to i32
  %102 = sext i32 %101 to i64
  %103 = call i64 @llvm.expect.i64(i64 %102, i64 0)
  %104 = icmp ne i64 %103, 0
  br i1 %104, label %105, label %118

105:                                              ; preds = %93
  %106 = load i8*, i8** %4, align 8
  %107 = getelementptr inbounds i8, i8* %106, i64 1
  %108 = load i8, i8* %107, align 1
  %109 = sext i8 %108 to i32
  %110 = icmp eq i32 %109, 80
  br i1 %110, label %111, label %118

111:                                              ; preds = %105
  %112 = load i32, i32* %7, align 4
  %113 = sub i32 %112, 2
  %114 = load i32, i32* %13, align 4
  %115 = add i32 %114, %113
  store i32 %115, i32* %13, align 4
  %116 = load i8*, i8** %4, align 8
  %117 = getelementptr inbounds i8, i8* %116, i32 1
  store i8* %117, i8** %4, align 8
  br label %134

118:                                              ; preds = %105, %93
  %119 = load i8*, i8** %4, align 8
  %120 = getelementptr inbounds i8, i8* %119, i64 0
  %121 = load i8, i8* %120, align 1
  %122 = sext i8 %121 to i32
  %123 = icmp eq i32 %122, 92
  %124 = xor i1 %123, true
  %125 = xor i1 %124, true
  %126 = zext i1 %125 to i32
  %127 = sext i32 %126 to i64
  %128 = call i64 @llvm.expect.i64(i64 %127, i64 0)
  %129 = icmp ne i64 %128, 0
  br i1 %129, label %130, label %133

130:                                              ; preds = %118
  %131 = load i8*, i8** %4, align 8
  %132 = getelementptr inbounds i8, i8* %131, i32 1
  store i8* %132, i8** %4, align 8
  br label %133

133:                                              ; preds = %130, %118
  br label %134

134:                                              ; preds = %133, %111
  br label %135

135:                                              ; preds = %134, %86
  br label %136

136:                                              ; preds = %135
  %137 = load i8*, i8** %4, align 8
  %138 = getelementptr inbounds i8, i8* %137, i32 1
  store i8* %138, i8** %4, align 8
  br label %64

139:                                              ; preds = %64
  %140 = load i8*, i8** %4, align 8
  %141 = load i8*, i8** %2, align 8
  %142 = ptrtoint i8* %140 to i64
  %143 = ptrtoint i8* %141 to i64
  %144 = sub i64 %142, %143
  %145 = add nsw i64 %144, 1
  %146 = load i32, i32* %13, align 4
  %147 = zext i32 %146 to i64
  %148 = add nsw i64 %147, %145
  %149 = trunc i64 %148 to i32
  store i32 %149, i32* %13, align 4
  %150 = load i32, i32* %13, align 4
  %151 = zext i32 %150 to i64
  %152 = call noalias i8* @_emalloc(i64 %151) #8
  store i8* %152, i8** %3, align 8
  %153 = load i8*, i8** %2, align 8
  store i8* %153, i8** %4, align 8
  %154 = load i8*, i8** %3, align 8
  store i8* %154, i8** %5, align 8
  br label %155

155:                                              ; preds = %319, %139
  %156 = load i8*, i8** %4, align 8
  %157 = load i8, i8* %156, align 1
  %158 = icmp ne i8 %157, 0
  br i1 %158, label %159, label %322

159:                                              ; preds = %155
  %160 = load i8*, i8** %4, align 8
  %161 = load i8, i8* %160, align 1
  %162 = sext i8 %161 to i32
  %163 = icmp eq i32 %162, 32
  %164 = xor i1 %163, true
  %165 = xor i1 %164, true
  %166 = zext i1 %165 to i32
  %167 = sext i32 %166 to i64
  %168 = call i64 @llvm.expect.i64(i64 %167, i64 0)
  %169 = icmp ne i64 %168, 0
  br i1 %169, label %170, label %176

170:                                              ; preds = %159
  %171 = load i8*, i8** %5, align 8
  store i8* %171, i8** %15, align 8
  %172 = load i32, i32* %17, align 4
  %173 = add i32 %172, 1
  store i32 %173, i32* %17, align 4
  store i32 %172, i32* %16, align 4
  %174 = load i8*, i8** %5, align 8
  %175 = getelementptr inbounds i8, i8* %174, i32 1
  store i8* %175, i8** %5, align 8
  store i8 32, i8* %174, align 1
  br label %300

176:                                              ; preds = %159
  %177 = load i8*, i8** %4, align 8
  %178 = load i8, i8* %177, align 1
  %179 = sext i8 %178 to i32
  %180 = icmp eq i32 %179, 10
  %181 = xor i1 %180, true
  %182 = xor i1 %181, true
  %183 = zext i1 %182 to i32
  %184 = sext i32 %183 to i64
  %185 = call i64 @llvm.expect.i64(i64 %184, i64 0)
  %186 = icmp ne i64 %185, 0
  br i1 %186, label %187, label %192

187:                                              ; preds = %176
  store i8* null, i8** %15, align 8
  %188 = load i8*, i8** %4, align 8
  %189 = load i8, i8* %188, align 1
  %190 = load i8*, i8** %5, align 8
  %191 = getelementptr inbounds i8, i8* %190, i32 1
  store i8* %191, i8** %5, align 8
  store i8 %189, i8* %190, align 1
  store i32 0, i32* %16, align 4
  store i32 0, i32* %17, align 4
  br label %299

192:                                              ; preds = %176
  %193 = load i8*, i8** %4, align 8
  %194 = getelementptr inbounds i8, i8* %193, i64 0
  %195 = load i8, i8* %194, align 1
  %196 = sext i8 %195 to i32
  %197 = icmp eq i32 %196, 42
  %198 = xor i1 %197, true
  %199 = xor i1 %198, true
  %200 = zext i1 %199 to i32
  %201 = sext i32 %200 to i64
  %202 = call i64 @llvm.expect.i64(i64 %201, i64 0)
  %203 = icmp ne i64 %202, 0
  br i1 %203, label %204, label %236

204:                                              ; preds = %192
  %205 = load i8*, i8** %4, align 8
  %206 = getelementptr inbounds i8, i8* %205, i64 1
  %207 = load i8, i8* %206, align 1
  %208 = sext i8 %207 to i32
  %209 = icmp eq i32 %208, 42
  br i1 %209, label %210, label %236

210:                                              ; preds = %204
  %211 = load i32, i32* %11, align 4
  %212 = icmp ne i32 %211, 0
  br i1 %212, label %213, label %233

213:                                              ; preds = %210
  %214 = load i32, i32* %14, align 4
  %215 = icmp ne i32 %214, 0
  %216 = xor i1 %215, true
  %217 = zext i1 %216 to i32
  store i32 %217, i32* %14, align 4
  %218 = load i8*, i8** %5, align 8
  %219 = load i32, i32* %14, align 4
  %220 = icmp ne i32 %219, 0
  br i1 %220, label %221, label %223

221:                                              ; preds = %213
  %222 = load i8*, i8** %9, align 8
  br label %225

223:                                              ; preds = %213
  %224 = load i8*, i8** %10, align 8
  br label %225

225:                                              ; preds = %223, %221
  %226 = phi i8* [ %222, %221 ], [ %224, %223 ]
  %227 = load i32, i32* %11, align 4
  %228 = zext i32 %227 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %218, i8* align 1 %226, i64 %228, i1 false)
  %229 = load i32, i32* %11, align 4
  %230 = load i8*, i8** %5, align 8
  %231 = zext i32 %229 to i64
  %232 = getelementptr inbounds i8, i8* %230, i64 %231
  store i8* %232, i8** %5, align 8
  br label %233

233:                                              ; preds = %225, %210
  %234 = load i8*, i8** %4, align 8
  %235 = getelementptr inbounds i8, i8* %234, i32 1
  store i8* %235, i8** %4, align 8
  br label %298

236:                                              ; preds = %204, %192
  %237 = load i8*, i8** %4, align 8
  %238 = getelementptr inbounds i8, i8* %237, i64 0
  %239 = load i8, i8* %238, align 1
  %240 = sext i8 %239 to i32
  %241 = icmp eq i32 %240, 36
  %242 = xor i1 %241, true
  %243 = xor i1 %242, true
  %244 = zext i1 %243 to i32
  %245 = sext i32 %244 to i64
  %246 = call i64 @llvm.expect.i64(i64 %245, i64 0)
  %247 = icmp ne i64 %246, 0
  br i1 %247, label %248, label %268

248:                                              ; preds = %236
  %249 = load i8*, i8** %4, align 8
  %250 = getelementptr inbounds i8, i8* %249, i64 1
  %251 = load i8, i8* %250, align 1
  %252 = sext i8 %251 to i32
  %253 = icmp eq i32 %252, 80
  br i1 %253, label %254, label %268

254:                                              ; preds = %248
  %255 = load i8*, i8** %5, align 8
  %256 = load i8*, i8** %6, align 8
  %257 = load i32, i32* %7, align 4
  %258 = zext i32 %257 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 1 %255, i8* align 1 %256, i64 %258, i1 false)
  %259 = load i32, i32* %7, align 4
  %260 = load i8*, i8** %5, align 8
  %261 = zext i32 %259 to i64
  %262 = getelementptr inbounds i8, i8* %260, i64 %261
  store i8* %262, i8** %5, align 8
  %263 = load i32, i32* %8, align 4
  %264 = load i32, i32* %17, align 4
  %265 = add i32 %264, %263
  store i32 %265, i32* %17, align 4
  %266 = load i8*, i8** %4, align 8
  %267 = getelementptr inbounds i8, i8* %266, i32 1
  store i8* %267, i8** %4, align 8
  br label %297

268:                                              ; preds = %248, %236
  %269 = load i8*, i8** %4, align 8
  %270 = getelementptr inbounds i8, i8* %269, i64 0
  %271 = load i8, i8* %270, align 1
  %272 = sext i8 %271 to i32
  %273 = icmp eq i32 %272, 92
  %274 = xor i1 %273, true
  %275 = xor i1 %274, true
  %276 = zext i1 %275 to i32
  %277 = sext i32 %276 to i64
  %278 = call i64 @llvm.expect.i64(i64 %277, i64 0)
  %279 = icmp ne i64 %278, 0
  br i1 %279, label %280, label %289

280:                                              ; preds = %268
  %281 = load i8*, i8** %4, align 8
  %282 = getelementptr inbounds i8, i8* %281, i32 1
  store i8* %282, i8** %4, align 8
  %283 = load i8*, i8** %4, align 8
  %284 = load i8, i8* %283, align 1
  %285 = load i8*, i8** %5, align 8
  %286 = getelementptr inbounds i8, i8* %285, i32 1
  store i8* %286, i8** %5, align 8
  store i8 %284, i8* %285, align 1
  %287 = load i32, i32* %17, align 4
  %288 = add i32 %287, 1
  store i32 %288, i32* %17, align 4
  br label %296

289:                                              ; preds = %268
  %290 = load i8*, i8** %4, align 8
  %291 = load i8, i8* %290, align 1
  %292 = load i8*, i8** %5, align 8
  %293 = getelementptr inbounds i8, i8* %292, i32 1
  store i8* %293, i8** %5, align 8
  store i8 %291, i8* %292, align 1
  %294 = load i32, i32* %17, align 4
  %295 = add i32 %294, 1
  store i32 %295, i32* %17, align 4
  br label %296

296:                                              ; preds = %289, %280
  br label %297

297:                                              ; preds = %296, %254
  br label %298

298:                                              ; preds = %297, %233
  br label %299

299:                                              ; preds = %298, %187
  br label %300

300:                                              ; preds = %299, %170
  %301 = load i32, i32* %17, align 4
  %302 = load i32, i32* %12, align 4
  %303 = icmp uge i32 %301, %302
  %304 = xor i1 %303, true
  %305 = xor i1 %304, true
  %306 = zext i1 %305 to i32
  %307 = sext i32 %306 to i64
  %308 = call i64 @llvm.expect.i64(i64 %307, i64 0)
  %309 = icmp ne i64 %308, 0
  br i1 %309, label %310, label %318

310:                                              ; preds = %300
  %311 = load i8*, i8** %15, align 8
  %312 = icmp ne i8* %311, null
  br i1 %312, label %313, label %318

313:                                              ; preds = %310
  %314 = load i8*, i8** %15, align 8
  store i8 10, i8* %314, align 1
  store i8* null, i8** %15, align 8
  %315 = load i32, i32* %16, align 4
  %316 = load i32, i32* %17, align 4
  %317 = sub i32 %316, %315
  store i32 %317, i32* %17, align 4
  store i32 0, i32* %16, align 4
  br label %318

318:                                              ; preds = %313, %310, %300
  br label %319

319:                                              ; preds = %318
  %320 = load i8*, i8** %4, align 8
  %321 = getelementptr inbounds i8, i8* %320, i32 1
  store i8* %321, i8** %4, align 8
  br label %155

322:                                              ; preds = %155
  %323 = load i8*, i8** %5, align 8
  %324 = getelementptr inbounds i8, i8* %323, i32 1
  store i8* %324, i8** %5, align 8
  store i8 0, i8* %323, align 1
  %325 = load i8*, i8** %5, align 8
  %326 = load i8*, i8** %3, align 8
  %327 = ptrtoint i8* %325 to i64
  %328 = ptrtoint i8* %326 to i64
  %329 = sub i64 %327, %328
  %330 = load i32, i32* %13, align 4
  %331 = zext i32 %330 to i64
  %332 = icmp sgt i64 %329, %331
  br i1 %332, label %333, label %344

333:                                              ; preds = %322
  %334 = load i32, i32* getelementptr inbounds (%4, %4* @phpdbg_globals, i32 0, i32 38, i64 1, i32 1), align 8
  %335 = load i8*, i8** %5, align 8
  %336 = load i8*, i8** %3, align 8
  %337 = ptrtoint i8* %335 to i64
  %338 = ptrtoint i8* %336 to i64
  %339 = sub i64 %337, %338
  %340 = load i32, i32* %13, align 4
  %341 = zext i32 %340 to i64
  %342 = sub nsw i64 %339, %341
  %343 = call i32 (i32, i32, i8*, i8*, i8*, ...) @phpdbg_print(i32 1, i32 %334, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @14, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @15, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @16, i32 0, i32 0), i64 %342)
  br label %344

344:                                              ; preds = %333, %322
  %345 = load i32, i32* getelementptr inbounds (%4, %4* @phpdbg_globals, i32 0, i32 38, i64 1, i32 1), align 8
  %346 = load i8*, i8** %3, align 8
  %347 = call i32 (i32, i8*, ...) @phpdbg_out_internal(i32 %345, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @17, i32 0, i32 0), i8* %346)
  %348 = load i8*, i8** %3, align 8
  call void @_efree(i8* %348)
  store i32 0, i32* %18, align 4
  br label %349

349:                                              ; preds = %344, %58
  %350 = bitcast i32* %17 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %350) #6
  %351 = bitcast i32* %16 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %351) #6
  %352 = bitcast i8** %15 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %352) #6
  %353 = bitcast i32* %14 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %353) #6
  %354 = bitcast i32* %13 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %354) #6
  %355 = bitcast i32* %12 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %355) #6
  %356 = bitcast i32* %11 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %356) #6
  %357 = bitcast i8** %10 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %357) #6
  %358 = bitcast i8** %9 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %358) #6
  %359 = bitcast i32* %8 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %359) #6
  %360 = bitcast i32* %7 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %360) #6
  %361 = bitcast i8** %6 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %361) #6
  %362 = bitcast i8** %5 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %362) #6
  %363 = bitcast i8** %4 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %363) #6
  %364 = bitcast i8** %3 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %364) #6
  %365 = load i32, i32* %18, align 4
  switch i32 %365, label %367 [
    i32 0, label %366
    i32 1, label %366
  ]

366:                                              ; preds = %349, %349
  ret void

367:                                              ; preds = %349
  unreachable
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture) #1

declare dso_local i8* @phpdbg_get_prompt() #2

; Function Attrs: nounwind readonly
declare dso_local i64 @strlen(i8*) #3

declare dso_local i32 @phpdbg_get_terminal_width() #2

declare dso_local i32 @phpdbg_xml_internal(i32, i8*, ...) #2

; Function Attrs: nounwind readnone willreturn
declare i64 @llvm.expect.i64(i64, i64) #4

; Function Attrs: allocsize(0)
declare dso_local noalias i8* @_emalloc(i64) #5

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* noalias nocapture writeonly, i8* noalias nocapture readonly, i64, i1 immarg) #1

declare dso_local i32 @phpdbg_print(i32, i32, i8*, i8*, i8*, ...) #2

declare dso_local i32 @phpdbg_out_internal(i32, i8*, ...) #2

declare dso_local void @_efree(i8*) #2

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture) #1

; Function Attrs: nounwind uwtable
define hidden void @summary_print(%0* %0) #0 {
  %2 = alloca %0*, align 8
  %3 = alloca i8*, align 8
  store %0* %0, %0** %2, align 8
  %4 = bitcast i8** %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %4) #6
  %5 = load %0*, %0** %2, align 8
  %6 = getelementptr inbounds %0, %0* %5, i32 0, i32 0
  %7 = load i8*, i8** %6, align 8
  %8 = load %0*, %0** %2, align 8
  %9 = getelementptr inbounds %0, %0* %8, i32 0, i32 4
  %10 = load i8, i8* %9, align 8
  %11 = sext i8 %10 to i32
  %12 = load %0*, %0** %2, align 8
  %13 = getelementptr inbounds %0, %0* %12, i32 0, i32 2
  %14 = load i8*, i8** %13, align 8
  %15 = call i64 (i8**, i64, i8*, ...) @zend_spprintf(i8** %3, i64 0, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @18, i32 0, i32 0), i8* %7, i32 %11, i8* %14)
  %16 = load i8*, i8** %3, align 8
  call void @pretty_print(i8* %16)
  %17 = load i8*, i8** %3, align 8
  call void @_efree(i8* %17)
  %18 = bitcast i8** %3 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %18) #6
  ret void
}

declare dso_local i64 @zend_spprintf(i8**, i64, i8*, ...) #2

; Function Attrs: nounwind uwtable
define hidden void @phpdbg_do_help_cmd(i8* %0) #0 {
  %2 = alloca i8*, align 8
  %3 = alloca i8*, align 8
  %4 = alloca i32, align 4
  store i8* %0, i8** %2, align 8
  %5 = bitcast i8** %3 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %5) #6
  %6 = load i8*, i8** %2, align 8
  %7 = icmp ne i8* %6, null
  br i1 %7, label %10, label %8

8:                                                ; preds = %1
  %9 = call i8* @96(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @19, i32 0, i32 0))
  call void @pretty_print(i8* %9)
  store i32 1, i32* %4, align 4
  br label %23

10:                                               ; preds = %1
  %11 = load i8*, i8** %2, align 8
  %12 = call i8* @96(i8* %11)
  store i8* %12, i8** %3, align 8
  %13 = load i8*, i8** %3, align 8
  %14 = icmp ne i8* %13, null
  br i1 %14, label %15, label %19

15:                                               ; preds = %10
  %16 = load i8*, i8** %3, align 8
  %17 = call i32 @memcmp(i8* %16, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @11, i32 0, i32 0), i64 1) #7
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %19, label %21

19:                                               ; preds = %15, %10
  %20 = call i8* @96(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @19, i32 0, i32 0))
  call void @pretty_print(i8* %20)
  call void @pretty_print(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @20, i32 0, i32 0))
  store i32 1, i32* %4, align 4
  br label %23

21:                                               ; preds = %15
  %22 = load i8*, i8** %3, align 8
  call void @pretty_print(i8* %22)
  store i32 0, i32* %4, align 4
  br label %23

23:                                               ; preds = %21, %19, %8
  %24 = bitcast i8** %3 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %24) #6
  %25 = load i32, i32* %4, align 4
  switch i32 %25, label %27 [
    i32 0, label %26
    i32 1, label %26
  ]

26:                                               ; preds = %23, %23
  ret void

27:                                               ; preds = %23
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i8* @96(i8* %0) #0 {
  %2 = alloca i8*, align 8
  %3 = alloca i8*, align 8
  %4 = alloca %86*, align 8
  %5 = alloca i32, align 4
  store i8* %0, i8** %3, align 8
  %6 = bitcast %86** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %6) #6
  store %86* getelementptr inbounds ([32 x %86], [32 x %86]* @phpdbg_help_text, i32 0, i32 0), %86** %4, align 8
  br label %7

7:                                                ; preds = %24, %1
  %8 = load %86*, %86** %4, align 8
  %9 = getelementptr inbounds %86, %86* %8, i32 0, i32 0
  %10 = load i8*, i8** %9, align 8
  %11 = icmp ne i8* %10, null
  br i1 %11, label %12, label %27

12:                                               ; preds = %7
  %13 = load %86*, %86** %4, align 8
  %14 = getelementptr inbounds %86, %86* %13, i32 0, i32 0
  %15 = load i8*, i8** %14, align 8
  %16 = load i8*, i8** %3, align 8
  %17 = call i32 @strcmp(i8* %15, i8* %16) #7
  %18 = icmp ne i32 %17, 0
  br i1 %18, label %23, label %19

19:                                               ; preds = %12
  %20 = load %86*, %86** %4, align 8
  %21 = getelementptr inbounds %86, %86* %20, i32 0, i32 1
  %22 = load i8*, i8** %21, align 8
  store i8* %22, i8** %2, align 8
  store i32 1, i32* %5, align 4
  br label %28

23:                                               ; preds = %12
  br label %24

24:                                               ; preds = %23
  %25 = load %86*, %86** %4, align 8
  %26 = getelementptr inbounds %86, %86* %25, i32 1
  store %86* %26, %86** %4, align 8
  br label %7

27:                                               ; preds = %7
  store i8* getelementptr inbounds ([1 x i8], [1 x i8]* @11, i32 0, i32 0), i8** %2, align 8
  store i32 1, i32* %5, align 4
  br label %28

28:                                               ; preds = %27, %19
  %29 = bitcast %86** %4 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %29) #6
  %30 = load i8*, i8** %2, align 8
  ret i8* %30
}

; Function Attrs: nounwind readonly
declare dso_local i32 @memcmp(i8*, i8*, i64) #3

; Function Attrs: nounwind uwtable
define hidden i32 @phpdbg_do_help(%1* %0) #0 {
  %2 = alloca i32, align 4
  %3 = alloca %1*, align 8
  %4 = alloca %0*, align 8
  %5 = alloca i32, align 4
  %6 = alloca i32, align 4
  store %1* %0, %1** %3, align 8
  %7 = bitcast %0** %4 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %7) #6
  %8 = bitcast i32* %5 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %8) #6
  %9 = load %1*, %1** %3, align 8
  %10 = icmp ne %1* %9, null
  br i1 %10, label %11, label %16

11:                                               ; preds = %1
  %12 = load %1*, %1** %3, align 8
  %13 = getelementptr inbounds %1, %1* %12, i32 0, i32 0
  %14 = load i32, i32* %13, align 8
  %15 = icmp eq i32 %14, 0
  br i1 %15, label %16, label %18

16:                                               ; preds = %11, %1
  %17 = call i8* @96(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @19, i32 0, i32 0))
  call void @pretty_print(i8* %17)
  store i32 0, i32* %2, align 4
  store i32 1, i32* %6, align 4
  br label %116

18:                                               ; preds = %11
  %19 = load %1*, %1** %3, align 8
  %20 = icmp ne %1* %19, null
  br i1 %20, label %21, label %115

21:                                               ; preds = %18
  %22 = load %1*, %1** %3, align 8
  %23 = getelementptr inbounds %1, %1* %22, i32 0, i32 0
  %24 = load i32, i32* %23, align 8
  %25 = icmp eq i32 %24, 5
  br i1 %25, label %26, label %115

26:                                               ; preds = %21
  %27 = load %1*, %1** %3, align 8
  %28 = getelementptr inbounds %1, %1* %27, i32 0, i32 5
  %29 = load i8*, i8** %28, align 8
  %30 = load %1*, %1** %3, align 8
  %31 = getelementptr inbounds %1, %1* %30, i32 0, i32 6
  %32 = load i64, i64* %31, align 8
  %33 = call i32 @97(i8* %29, i64 %32, %0** %4, %0* getelementptr inbounds ([0 x %0], [0 x %0]* @phpdbg_prompt_commands, i32 0, i32 0))
  store i32 %33, i32* %5, align 4
  %34 = load i32, i32* %5, align 4
  %35 = icmp eq i32 %34, 1
  br i1 %35, label %36, label %42

36:                                               ; preds = %26
  %37 = load %0*, %0** %4, align 8
  call void @summary_print(%0* %37)
  %38 = load %0*, %0** %4, align 8
  %39 = getelementptr inbounds %0, %0* %38, i32 0, i32 0
  %40 = load i8*, i8** %39, align 8
  %41 = call i8* @96(i8* %40)
  call void @pretty_print(i8* %41)
  store i32 0, i32* %2, align 4
  store i32 1, i32* %6, align 4
  br label %116

42:                                               ; preds = %26
  %43 = load i32, i32* %5, align 4
  %44 = icmp sgt i32 %43, 1
  br i1 %44, label %45, label %85

45:                                               ; preds = %42
  %46 = load %1*, %1** %3, align 8
  %47 = getelementptr inbounds %1, %1* %46, i32 0, i32 6
  %48 = load i64, i64* %47, align 8
  %49 = icmp ugt i64 %48, 1
  br i1 %49, label %50, label %76

50:                                               ; preds = %45
  store %0* getelementptr inbounds ([0 x %0], [0 x %0]* @phpdbg_prompt_commands, i32 0, i32 0), %0** %4, align 8
  br label %51

51:                                               ; preds = %71, %50
  %52 = load %0*, %0** %4, align 8
  %53 = getelementptr inbounds %0, %0* %52, i32 0, i32 0
  %54 = load i8*, i8** %53, align 8
  %55 = icmp ne i8* %54, null
  br i1 %55, label %56, label %74

56:                                               ; preds = %51
  %57 = load %0*, %0** %4, align 8
  %58 = getelementptr inbounds %0, %0* %57, i32 0, i32 0
  %59 = load i8*, i8** %58, align 8
  %60 = load %1*, %1** %3, align 8
  %61 = getelementptr inbounds %1, %1* %60, i32 0, i32 5
  %62 = load i8*, i8** %61, align 8
  %63 = load %1*, %1** %3, align 8
  %64 = getelementptr inbounds %1, %1* %63, i32 0, i32 6
  %65 = load i64, i64* %64, align 8
  %66 = call i32 @strncmp(i8* %59, i8* %62, i64 %65) #7
  %67 = icmp ne i32 %66, 0
  br i1 %67, label %70, label %68

68:                                               ; preds = %56
  %69 = load %0*, %0** %4, align 8
  call void @summary_print(%0* %69)
  br label %70

70:                                               ; preds = %68, %56
  br label %71

71:                                               ; preds = %70
  %72 = load %0*, %0** %4, align 8
  %73 = getelementptr inbounds %0, %0* %72, i32 1
  store %0* %73, %0** %4, align 8
  br label %51

74:                                               ; preds = %51
  %75 = call i8* @96(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @21, i32 0, i32 0))
  call void @pretty_print(i8* %75)
  store i32 0, i32* %2, align 4
  store i32 1, i32* %6, align 4
  br label %116

76:                                               ; preds = %45
  %77 = load i32, i32* getelementptr inbounds (%4, %4* @phpdbg_globals, i32 0, i32 38, i64 1, i32 1), align 8
  %78 = load %1*, %1** %3, align 8
  %79 = getelementptr inbounds %1, %1* %78, i32 0, i32 5
  %80 = load i8*, i8** %79, align 8
  %81 = getelementptr inbounds i8, i8* %80, i64 0
  %82 = load i8, i8* %81, align 1
  %83 = sext i8 %82 to i32
  %84 = call i32 (i32, i32, i8*, i8*, i8*, ...) @phpdbg_print(i32 1, i32 %77, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @14, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @22, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @23, i32 0, i32 0), i32 %83)
  store i32 -1, i32* %2, align 4
  store i32 1, i32* %6, align 4
  br label %116

85:                                               ; preds = %42
  %86 = load %1*, %1** %3, align 8
  %87 = getelementptr inbounds %1, %1* %86, i32 0, i32 5
  %88 = load i8*, i8** %87, align 8
  %89 = load %1*, %1** %3, align 8
  %90 = getelementptr inbounds %1, %1* %89, i32 0, i32 6
  %91 = load i64, i64* %90, align 8
  %92 = call i32 @97(i8* %88, i64 %91, %0** %4, %0* getelementptr inbounds ([6 x %0], [6 x %0]* @phpdbg_help_commands, i32 0, i32 0))
  store i32 %92, i32* %5, align 4
  %93 = load i32, i32* %5, align 4
  %94 = icmp sgt i32 %93, 0
  br i1 %94, label %95, label %112

95:                                               ; preds = %85
  %96 = load %0*, %0** %4, align 8
  %97 = getelementptr inbounds %0, %0* %96, i32 0, i32 4
  %98 = load i8, i8* %97, align 8
  %99 = sext i8 %98 to i32
  %100 = icmp eq i32 %99, 97
  br i1 %100, label %101, label %107

101:                                              ; preds = %95
  %102 = load %0*, %0** %4, align 8
  %103 = getelementptr inbounds %0, %0* %102, i32 0, i32 5
  %104 = load i32 (%1*)*, i32 (%1*)** %103, align 8
  %105 = load %1*, %1** %3, align 8
  %106 = call i32 %104(%1* %105)
  store i32 %106, i32* %2, align 4
  store i32 1, i32* %6, align 4
  br label %116

107:                                              ; preds = %95
  %108 = load %0*, %0** %4, align 8
  %109 = getelementptr inbounds %0, %0* %108, i32 0, i32 0
  %110 = load i8*, i8** %109, align 8
  %111 = call i8* @96(i8* %110)
  call void @pretty_print(i8* %111)
  store i32 0, i32* %2, align 4
  store i32 1, i32* %6, align 4
  br label %116

112:                                              ; preds = %85
  br label %113

113:                                              ; preds = %112
  br label %114

114:                                              ; preds = %113
  br label %115

115:                                              ; preds = %114, %21, %18
  store i32 -1, i32* %2, align 4
  store i32 1, i32* %6, align 4
  br label %116

116:                                              ; preds = %115, %107, %101, %76, %74, %36, %16
  %117 = bitcast i32* %5 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %117) #6
  %118 = bitcast %0** %4 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %118) #6
  %119 = load i32, i32* %2, align 4
  ret i32 %119
}

; Function Attrs: nounwind uwtable
define internal i32 @97(i8* %0, i64 %1, %0** %2, %0* %3) #0 {
  %5 = alloca i8*, align 8
  %6 = alloca i64, align 8
  %7 = alloca %0**, align 8
  %8 = alloca %0*, align 8
  %9 = alloca %0*, align 8
  %10 = alloca i32, align 4
  store i8* %0, i8** %5, align 8
  store i64 %1, i64* %6, align 8
  store %0** %2, %0*** %7, align 8
  store %0* %3, %0** %8, align 8
  %11 = bitcast %0** %9 to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* %11) #6
  %12 = bitcast i32* %10 to i8*
  call void @llvm.lifetime.start.p0i8(i64 4, i8* %12) #6
  store i32 0, i32* %10, align 4
  %13 = load i64, i64* %6, align 8
  %14 = icmp eq i64 %13, 1
  br i1 %14, label %15, label %49

15:                                               ; preds = %4
  %16 = load %0*, %0** %8, align 8
  store %0* %16, %0** %9, align 8
  br label %17

17:                                               ; preds = %45, %15
  %18 = load %0*, %0** %9, align 8
  %19 = getelementptr inbounds %0, %0* %18, i32 0, i32 0
  %20 = load i8*, i8** %19, align 8
  %21 = icmp ne i8* %20, null
  br i1 %21, label %22, label %48

22:                                               ; preds = %17
  %23 = load %0*, %0** %9, align 8
  %24 = getelementptr inbounds %0, %0* %23, i32 0, i32 4
  %25 = load i8, i8* %24, align 8
  %26 = sext i8 %25 to i32
  %27 = load i8*, i8** %5, align 8
  %28 = getelementptr inbounds i8, i8* %27, i64 0
  %29 = load i8, i8* %28, align 1
  %30 = sext i8 %29 to i32
  %31 = icmp eq i32 %26, %30
  br i1 %31, label %32, label %44

32:                                               ; preds = %22
  %33 = load i32, i32* %10, align 4
  %34 = add i32 %33, 1
  store i32 %34, i32* %10, align 4
  %35 = load i32, i32* %10, align 4
  %36 = icmp eq i32 %35, 1
  br i1 %36, label %37, label %43

37:                                               ; preds = %32
  %38 = load %0**, %0*** %7, align 8
  %39 = icmp ne %0** %38, null
  br i1 %39, label %40, label %43

40:                                               ; preds = %37
  %41 = load %0*, %0** %9, align 8
  %42 = load %0**, %0*** %7, align 8
  store %0* %41, %0** %42, align 8
  br label %43

43:                                               ; preds = %40, %37, %32
  br label %44

44:                                               ; preds = %43, %22
  br label %45

45:                                               ; preds = %44
  %46 = load %0*, %0** %9, align 8
  %47 = getelementptr inbounds %0, %0* %46, i32 1
  store %0* %47, %0** %9, align 8
  br label %17

48:                                               ; preds = %17
  br label %81

49:                                               ; preds = %4
  %50 = load %0*, %0** %8, align 8
  store %0* %50, %0** %9, align 8
  br label %51

51:                                               ; preds = %77, %49
  %52 = load %0*, %0** %9, align 8
  %53 = getelementptr inbounds %0, %0* %52, i32 0, i32 0
  %54 = load i8*, i8** %53, align 8
  %55 = icmp ne i8* %54, null
  br i1 %55, label %56, label %80

56:                                               ; preds = %51
  %57 = load %0*, %0** %9, align 8
  %58 = getelementptr inbounds %0, %0* %57, i32 0, i32 0
  %59 = load i8*, i8** %58, align 8
  %60 = load i8*, i8** %5, align 8
  %61 = load i64, i64* %6, align 8
  %62 = call i32 @strncmp(i8* %59, i8* %60, i64 %61) #7
  %63 = icmp ne i32 %62, 0
  br i1 %63, label %76, label %64

64:                                               ; preds = %56
  %65 = load i32, i32* %10, align 4
  %66 = add i32 %65, 1
  store i32 %66, i32* %10, align 4
  %67 = load i32, i32* %10, align 4
  %68 = icmp eq i32 %67, 1
  br i1 %68, label %69, label %75

69:                                               ; preds = %64
  %70 = load %0**, %0*** %7, align 8
  %71 = icmp ne %0** %70, null
  br i1 %71, label %72, label %75

72:                                               ; preds = %69
  %73 = load %0*, %0** %9, align 8
  %74 = load %0**, %0*** %7, align 8
  store %0* %73, %0** %74, align 8
  br label %75

75:                                               ; preds = %72, %69, %64
  br label %76

76:                                               ; preds = %75, %56
  br label %77

77:                                               ; preds = %76
  %78 = load %0*, %0** %9, align 8
  %79 = getelementptr inbounds %0, %0* %78, i32 1
  store %0* %79, %0** %9, align 8
  br label %51

80:                                               ; preds = %51
  br label %81

81:                                               ; preds = %80, %48
  %82 = load i32, i32* %10, align 4
  %83 = bitcast i32* %10 to i8*
  call void @llvm.lifetime.end.p0i8(i64 4, i8* %83) #6
  %84 = bitcast %0** %9 to i8*
  call void @llvm.lifetime.end.p0i8(i64 8, i8* %84) #6
  ret i32 %82
}

; Function Attrs: nounwind readonly
declare dso_local i32 @strncmp(i8*, i8*, i64) #3

; Function Attrs: nounwind readonly
declare dso_local i32 @strcmp(i8*, i8*) #3

attributes #0 = { nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { argmemonly nounwind willreturn }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readnone willreturn }
attributes #5 = { allocsize(0) "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="none" "less-precise-fpmad"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind }
attributes #7 = { nounwind readonly }
attributes #8 = { allocsize(0) }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 7.0.0 (tags/RELEASE_700/final)"}
